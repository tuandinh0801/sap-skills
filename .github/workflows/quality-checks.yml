name: Quality Checks

on:
  pull_request:
    branches: [main]
    paths:
      - 'skills/**'
      - '.github/**'
      - '*.md'

jobs:
  validate-skills:
    name: Validate Skill Files
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Validate YAML frontmatter
        run: |
          echo "Checking YAML frontmatter in SKILL.md files..."
          FAILED=0
          for file in skills/*/SKILL.md; do
            if [ ! -f "$file" ]; then
              continue
            fi
            
            # Check for both opening and closing frontmatter delimiters
            if ! /usr/bin/head -1 "$file" | grep -q "^---" || ! awk '/^---/{c++}c==2{exit}END{exit c!=2}' "$file"; then
              echo "❌ Invalid or incomplete frontmatter (must start and end with ---): $file"
              FAILED=1
            else
              echo "✅ Valid frontmatter: $file"
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo "❌ Some files have invalid or incomplete YAML frontmatter"
            exit 1
          fi
          echo "✅ All SKILL.md files have valid frontmatter"
      
      - name: Check license field
        run: |
          echo "Checking GPL-3.0 license in SKILL.md files..."
          FAILED=0
          for file in skills/*/SKILL.md; do
            if [ ! -f "$file" ]; then
              continue
            fi
            
            if ! grep -q "license: GPL-3.0" "$file"; then
              echo "❌ Wrong or missing license: $file"
              FAILED=1
            else
              echo "✅ Correct license: $file"
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo "❌ Some files have incorrect license field"
            exit 1
          fi
          echo "✅ All SKILL.md files have GPL-3.0 license"
      
      - name: Validate skill structure
        run: |
          echo "Checking required files in skill directories..."
          GLOBAL_FAILED=0
          for dir in skills/*/; do
            skill_name=$(basename "$dir")
            FAILED=0  # Reset per-directory failure flag
            
            # Skip if not a directory
            if [ ! -d "$dir" ]; then
              continue
            fi
            
            # Check for SKILL.md
            if [ ! -f "${dir}SKILL.md" ]; then
              echo "❌ Missing SKILL.md in: $skill_name"
              FAILED=1
              GLOBAL_FAILED=1
            fi
            
            # Check for README.md
            if [ ! -f "${dir}README.md" ]; then
              echo "❌ Missing README.md in: $skill_name"
              FAILED=1
              GLOBAL_FAILED=1
            fi
            
            if [ $FAILED -eq 0 ]; then
              echo "✅ Valid structure: $skill_name"
            fi
          done
          
          if [ $GLOBAL_FAILED -eq 1 ]; then
            echo "❌ Some skills have invalid structure"
            exit 1
          fi
          echo "✅ All skills have required files"
      
      - name: Check for broken internal links
        run: |
          echo "Checking for broken internal links..."
          FAILED=0
          
          # Create a temporary file to collect all broken links
          BROKEN_LINKS_FILE=$(mktemp)
          
          # Check if referenced files exist
          # Use find with -print0 and read with -d '' to handle filenames with spaces
          while IFS= read -r -d '' file; do
            # Extract markdown links while skipping code blocks, inline code, and escaped syntax
            awk '
              # Track if we are inside a fenced code block
              /^```/ { in_code_block = !in_code_block; next }

              # Skip lines inside code blocks
              in_code_block { next }

              # Process each line that is not in a code block
              {
                # Save original line
                line = $0

                # Remove inline code sections (` ... `)
                while (match(line, /`[^`]*`/)) {
                  line = substr(line, 1, RSTART-1) substr(line, RSTART+RLENGTH)
                }

                # Remove escaped markdown links (\[...\](...))
                gsub(/\\\[[^]]*\\\]\([^)]*\)/, "", line)

                # Extract and print all markdown links
                while (match(line, /\[[^]]+\]\([^)#]+\)/)) {
                  link_match = substr(line, RSTART, RLENGTH)
                  # Extract the URL part from [text](url) - match ](url) to avoid parentheses in link text
                  if (match(link_match, /\]\([^)#]+\)/)) {
                    url = substr(link_match, RSTART+2, RLENGTH-3)
                    # Skip external links
                    if (url !~ /^https?:\/\//) {
                      print url
                    }
                  }
                  # Continue searching after this match
                  line = substr(line, RSTART + RLENGTH)
                }
              }
            ' "$file" > "${BROKEN_LINKS_FILE}.links" 2>/dev/null || true

            # Process each link without using pipes (to avoid subshells)
            if [ -s "${BROKEN_LINKS_FILE}.links" ]; then
              exec 3< "${BROKEN_LINKS_FILE}.links"
              while IFS= read -r link <&3; do
                # Skip empty lines and external links
                [ -z "$link" ] && continue
                [[ "$link" =~ ^https?:// ]] && continue
                
                # Get directory of the current file
                dir=$(dirname "$file")
                
                # Resolve the target path safely
                link_dir=$(dirname "$link")
                link_base=$(basename "$link")
                
                # Handle case where link has no directory (just a filename)
                if [ "$link_dir" = "." ]; then
                  target="$dir/$link"
                else
                  # Check if the link's directory exists before trying to cd into it
                  if [ ! -d "$dir/$link_dir" ]; then
                    echo "❌ Broken link in $file: $link (directory $link_dir does not exist)" >> "$BROKEN_LINKS_FILE"
                    continue
                  fi
                  
                  # Safely resolve the target path
                  if ! target=$(cd "$dir" && cd "$link_dir" && pwd 2>/dev/null); then
                    echo "❌ Broken link in $file: $link (cannot resolve path $link_dir)" >> "$BROKEN_LINKS_FILE"
                    continue
                  fi
                  target="$target/$link_base"
                fi
                
                # Check if the resolved target exists
                if [ ! -f "$target" ] && [ ! -d "$target" ]; then
                  echo "❌ Broken link in $file: $link -> $target" >> "$BROKEN_LINKS_FILE"
                fi
              done
              exec 3<&-
            fi
            
            # Clean up links file
            rm -f "${BROKEN_LINKS_FILE}.links" 2>/dev/null || true
          done < <(find . -name "*.md" -type f -print0)
          
          # Check if any broken links were found
          if [ -s "$BROKEN_LINKS_FILE" ]; then
            FAILED=1
            cat "$BROKEN_LINKS_FILE"
          fi
          
          # Clean up
          rm -f "$BROKEN_LINKS_FILE" 2>/dev/null || true
          
          if [ $FAILED -eq 1 ]; then
            echo "❌ Some broken links were detected"
            exit 1
          fi
          echo "✅ Internal link check complete"
